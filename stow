#!/usr/bin/python3

# The person who associated a work with this deed has dedicated the work to the
# public domain by waiving all of his or her rights to the work worldwide under
# copyright law, including all related and neighboring rights, to the extent
# allowed by law.
#
# You can copy, modify, distribute and perform the work, even for commercial
# purposes, all without asking permission.
#
# AFFIRMER OFFERS THE WORK AS-IS AND MAKES NO REPRESENTATIONS OR WARRANTIES OF
# ANY KIND CONCERNING THE WORK, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE,
# INCLUDING WITHOUT LIMITATION WARRANTIES OF TITLE, MERCHANTABILITY, FITNESS
# FOR A PARTICULAR PURPOSE, NON INFRINGEMENT, OR THE ABSENCE OF LATENT OR OTHER
# DEFECTS, ACCURACY, OR THE PRESENT OR ABSENCE OF ERRORS, WHETHER OR NOT
# DISCOVERABLE, ALL TO THE GREATEST EXTENT PERMISSIBLE UNDER APPLICABLE LAW.
#
# For more information, please see
# <http://creativecommons.org/publicdomain/zero/1.0/>

import os.path as path
from ansible.module_utils.basic import *


def purge_conflicts(conflicted_files):
    for f in conflicted_files:
        pass

    return False, dict(message=None)


def stow_in_path(module):
    rc, _, _ = module.run_command('which stow', check_rc=False)
    return rc == 0


def stow_has_conflicts(module, flags):
    cmd = '{} --no'.format(flags)

    rc, _, stderr = module.run_command(cmd)

    msg = None
    conflicts = []

    if stderr:
        stderr_lines = stderr.split('\n')

        for s in stderr_lines:
            if '* existing target is neither' in s:
                c = s.split(':')
                c = c[1].strip()
                c = path.join(module.params['target'], c)

                conflicts.append(c)

    has_conflicts = (rc != 0)
    if has_conflicts:
        msg = 'unable to stow package "{0}" to "{1}"; conflicted files: {2}'.format(
            module.params['package'], module.params['dir'],
            ', '.join('"{}"'.format(f) for f in conflicts))

    return has_conflicts, dict(conflicts=conflicts, message=msg)


def stow(module, state):
    flag = ''
    if state == 'present' or state == 'supress':
        flag = '--stow'

    elif state == 'absent':
        flag = '--delete'

    elif state == 'latest':
        flag = '--restow'

    cmd = 'stow {0} {1} --target={2} --dir={3} --verbose'.format(
        flag,
        module.params['package'],
        module.params['target'],
        module.params['dir'])

    has_conflicts, res = stow_has_conflicts(module, cmd)
    if has_conflicts:
        if state != 'supress':
            return True, res
        
        err = purge_conflicts(res['conflicts'])
        if err:
            return True, res

    rc, stdout, stderr = module.run_command(cmd)
    if rc != 0:
        msg = 'execution of command "{0}" failed with error code {1}; output: "{2}"'.format(
            cmd, rc, stderr)

        return True, dict(message=msg)

    return False, dict(changed=(stderr != ''))


def main():
    module = AnsibleModule(argument_spec={
        'dir':     {'required': True, 'type': 'str'},
        'package': {'required': True, 'type': 'str'},
        'target':  {'required': False, 'type': 'str', 'default': '~'},
        'state':   {
            'required': True, 'type': 'str',
            'choices': ['absent', 'present', 'latest', 'supress']
        },
    })

    if not stow_in_path(module):
        module.fail_json(msg='unable to find stow')

    has_changed = False
    state = module.params['state']

    packages = list(module.params['package'])
    for package in packages:
        err, ret = stow(module, state)
        if err:
            module.fail_json(msg=ret['message'])

        has_changed = has_changed or ret['changed']

    module.exit_json(changed=has_changed)


if __name__ == '__main__':
    main()